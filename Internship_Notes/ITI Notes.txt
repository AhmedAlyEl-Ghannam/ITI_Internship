#Day 01 (1/8/2023)

Modulus Operator:
	-> (int(A/B) * B) + (A % B) = A // this equation is used to calculate the result of %
	-> @A = -ve => result is -ve
	-> @B = -ve => result is +ve (does not matter)
	
Difference between x++ && x = x + 1: 
	In order to understand the difference, examine the assembly code for both
	-> x++:	INC x // only a single assembly instruction
	
	-> x = x + 1:	LOAD x // requires
					MODIFY x // three
					STORE x // assembly instructions

----------------------------------------------------------------------------------
==================================================================================
----------------------------------------------------------------------------------

#Day 02 (2/8/2023) --- If & Loops

GCC inherently supports short-circuiting in logic operations
(Beware that parts of the statement can be outright skipped/not executed)
// Anything ANDed with 0 will always be 0 -> ignore it
// Anything ORed with 1 will always be 1 -> ignore it
==================================================================================
post/pre increment has undefined behaviour when used in printf 
==================================================================================
switch case: -> use look up table (jumps to case address directly)
			 -> consumes more memory (it is advisable to only not use switch in memory-constrained systems)
			 -> does not know when to stop (hence, break is mandatory)
			 -> const time in checking (unlike if you have to pass through ALL preceeding the required case)
			 -> for equality, switch case is way faster and more convenient
			 -> otherwise, use if/else (cant even use switch for non-int case values)
==================================================================================
for loop 	-> when the number of iterations is known
			-> declaring i inside for is supported in C99 and later
			-> counters declared in for loop can be seen outside the scope of 
				the loop in C11 and later

while loop	-> when waiting for an event that I do not know when it will happen

do while 	-> its body will be executed AT LEAST once before exiting the loop
==================================================================================
infinite loops	-> for (;;);
				-> while (1);
				
----------------------------------------------------------------------------------
==================================================================================
----------------------------------------------------------------------------------

#Day 03 (3/8/2023) --- Functions & Arrays

Beware of the following situation:
	char a, b;
	printf("enter a: ");
	scanf("%c", &a);
	// Must put fflush(stdin); here to avoid scanf crashing/misbehaving
	// upon pressing enter -> enter has an ASCII code itself
	printf("enter b: ");
	scanf("%c", &b);
	
Ternary operator:
	condition? instruction1(executed is condition is true) : instruction2 (executed is condition is false)
	
=================================================================================

Functions:
	-> Prototype
	-> Implementation/body
	-> Call
	
What happens behind the scenes when upon calling a function:
	-> store the context of execution (PC value)
	-> Jump to function address + update PC
	-> open a stack frame
	-> execute the function
	-> upon exiting, store the return value (if exists), 
		collapse the stack frame, update the program counter

Values given to a function upon calling == Parameters
Variables written in the function's prototype == Arguments

We can swap 2 numbers by:
	-> using a 3rd variable temp
		temp = x;
		x = y;
		y = temp;
		
	-> using xor (no 3rd variable used)
		x ^= y;
		y ^= x;
		x ^= y;
		
	-> using addition/subtraction (no 3rd variable used)
		x = x + y;
		y = x - y;
		x = x - y;
		
	-> using multiplication/division (no 3rd variable used)
		x = x * y;
		y = x / y;
		x = x / y;

Consider the following snippet:
	int x = 10; // global
	int main()
	{
		int x = 5; // local
		printf("%d", x); // prints 5 with no errors!
	}
	// it's as if the function looks within its scope first for 
		the variable x and since it has found it, it will not consider
		the global one.
		
Consider the following snippet:
	int x = 10;
	void change()
	{
		x++;
	}
	int main()
	{
		int x = 5;
		printf("%d", x); // prints 5
		change();		 // this niBBa changes the global x
		printf("%d", x); // also prints 5 XDDD
	}

=================================================================================

Arrays

Consider the following initialization of array:
	int x[5] = {2, 3}; // x = {2, 3, 0, 0, 0} (acceptable)
	
	int x[5] = {1, 2, 3, 4, 5, 6}; // compiler dependent! it will overwrite the
									  position after the array to 6

Sorting Algorithms (there are 7 of them!)
		1. Bubble Sort
		2. Quick Sort
		3. Merge Sort
Searching Algorithms (there are a lot more)
		1. Linear Search (loop iterating on all array elements)
		2. Binary Search (only for sorted elements)
		
----------------------------------------------------------------------------------
==================================================================================
----------------------------------------------------------------------------------
#Day 05 (6/8/2023)

Functions by default returns 1 (if you forgot to write return at the end)
It is advisable to write it yourself, tho (compiler independent behaviour)

you can use a function without using its return value (no errors)
	.
	.
	.
	add(x, y);
	int z = printf("%d", z); // z = no of characters (1 in this case)

printf returns the number of printed characters...! (it's often not used, tho)

scanf also has a return value! (returns the number of stored variables!)

consider this cursed code snippet:
	.
	.
	.
	switch(printf("DC"))
	{
		case 1: // case + break
		case 2: // case + break
		default: //
	}
	// no compilation errors
	// it will print DC, then switches on the value returned from printf
	// which is the number of printed characters (2) then execute case 2
	
interview question: How to print sth without semicolon?
Answer: put printf inside a condition/loop/switch statement	
if (printf("Ahmed")); // all non-zero values are considered true
// prints then executes if (in case of how I wrote it, if will only print)


#Pointers
	-> variables that carry address
	-> pointee_datatype * name;
		int ptr;
		ptr = &x; // &x = address of x
		int * ptr = &x;
	-> accessing/changing the value in the address stored in ptr // use dereference operator
		*ptr = 20; // *ptr = value of dereferenced ptr
	
	-> Pass by reference vs Pass by value
	-> Dangling pointer (a pointer to a mem location that no longer exists)
		like a pointer to a local variable in a function (unless you use static or sth)
	-> naming a pointer and a variable the same name is prohibited
		since pointers are still variables
	-> A Wild Pointer is an uninitialized pointer.
General rules of thumb:
	-> Always initialize your pointers to NULL
		NULL == out of range
		NULL == Zero (void*)0
		// pointer to a memory location out of range/safe
	-> When receiving a pointer in a function
		if (ptr != NULL)
		{
			// do the thing
		}
		else
		{
			// print error
		}
		
NOTES:
	1. pointee type
		-> access size/type
		-> step size
	2. Notation
		-> offset (*(ptr + i))
		-> subscriptor (arr[i])

----------------------------------------------------------------------------------
==================================================================================
----------------------------------------------------------------------------------
#Day 06 (7/8/2023)

Pointer shenanigans:
	-> you cannot assign a const value to a pointer
		int x = 0x30; // considered a value not an address
		int *ptr;
		ptr = x;
		// behaviour is compiler dependent
		// will either produce an error or a warning
		// assigning values this way will NEVER be considered
			an address

	-> sizeof(ptr) is always constant regardless of pointee type
	   and it is machine dependent (address will either be 4 or 8 bytes)
	-> for int*
		1. step = 4
		2. access = int
	-> for char*
		1. step = 1
		2. access = char
		
EXTRA Assignment: Swap the 1st and last bytes of an int using pointers
	int x = 0x99000011;
	
	char *byte1;
	char temp;
	
	byte1 = &x;
	
	printf("before swapping: %p\n", x);
	
	temp = *byte1;
	*byte1 = *(byte1 + 3);
	*(byte1 + 3) = temp;
	
	printf("after swapping: %p\n", x);
	
Literals in C
	-> decimal
		1. base 10 == 10, 20, 15
		2. binary (base 2) == 0b10010011
		3. octal (base 8) == 067 (always starts with 0)
		4. hexadecimal (base 16) == 0x6942
	-> floating 6.9 
	-> character 'A'
	-> string "ABC"
	
Pointer to function *SCREAMS*
	-> declaration:
		pointee_return_type (*name)(parameters' types)
		void (*func_ptr)(void) = func; // function name is a pointer to it
	-> calling:
		func_ptr(); // can be used just like the function itself
		// the advantages of this is to execute functions out of scope/in other files
		// also used for sth called "Callback"
	
Data Modifiers
	-> Datatypes
		1. Primitive (int, char, float, double, void)
		2. Derived (function, pointer, array)
		3. User-defined (struct, union, enum)
	-> How to represent signed numbers?
		1. Sign Magnitude
			MSB? 1 (-ve) : 0 (+ve)
			Problems = 2 values for zero & error-infested math operations
		2. 1's Complement
			Problems = STILL 2 values for zero
		3. 2's Complement
	-> for signed char
		0->127 +ve (any number over that will be -ve)
		-128->-1 -ve
	-> unsigned and signed keywords (only for char and int)
	
Size Modifiers
	-> char: not less than 1 byte
	-> int: not less than 2 bytes
	-> float: 				4 bytes
	-> double:				8 bytes
	Problem: datatype sizes are compiler dependent XDDD
			1. Memory overflow (big to small)
			2. Data loss (small to big)
	Solution: Define your own datatype! XDDD
	Syntax:
		typedef old_type new_type;
		// typedef is a keyword for renaming
	EX:
		typedef unsigned char u8;
		
		u8 x = 10; == unsigned char x = 10;
	1. short (for int only) -> limits int to 2 bytes
	2. long (int, double) -> limits int to 4 bytes
						  -> limits double to 10 bytes
	Rules:
		1. order is not important
			short unsigned int == unsigned short int
		2. not all modifiers can be used with all datatypes
			signed/unsigned (char and int only)
			short (int only)
			long (int and double)
		3. no opposing modifiers should be put together
			short long || signed unsigned
		
	OUR Standards:
		u for unsigned
		s for signed
		num for number of bits
		f for float
		
		u8
		s8
		u16
		s16
		u32
		s32
		f32
		f64
		
	## Before defining your datatypes, you must test the size of each
		datatypes using sizeof to design them accordingly
		
Symbol Table: (for each file, it lists all the used variables/functions in a file)
	Object 		| 	State
  var/fun name 	| provided/needed
	Linker is responsible for "linking" between files with dependencies.
	ie; if a function is used in a file and its implementation is in another file
	it will "link" both
	
	Object Verification:
		1. Make sure that every needed object is provided
			else: linker error "undefined reference to ..."
		2. Make sure every object is ONLY provided ONCE
			else: linker error "multiple definition..."

Storage Modifiers
	-> static (for global: restricts a variable to its file scope || for local/in function: retains its value until the program ends)
	-> extern (looks for object in other files)
	-> auto (all variables are auto by default - destroyed at the end of their lifetime)
	-> register (asks GCC if a certain variable can be stored in a GP register to speed up operations on it or not -- GCC the chad mostly refuses XDDD)
	
const Keyword: promises the compiler that it will not be changed
	const u8 x = 10; // trying to change x will cause an error
	-> Constant pointer: a pointer whose address value will not be changed
		int *const ptr = &x; // always points to x
		ptr = &y; // error
	-> Pointer to constant: pointer to an address whose value will not be changed
		const int* ptr = &x;
		*ptr = 30; // error
	-> Constant pointer to a constant!
		const int* const ptr = &x;
		// cant dereference it
		// cant change its address
		
	# constant variable hacking (BRUH!)
		const int x = 20;
		x = 30; // error
		int *ptr = &x;
		*ptr = 30; // it will pass IF it's local
				   // it's toolchain dependent IF it's global...!
	
----------------------------------------------------------------------------------
==================================================================================
----------------------------------------------------------------------------------
#Day 06 (8/8/2023)
void pointer
	-> sizeof(void) = compilation error OR 1?! (compiler dependent)
	-> void pointer is a generic pointer that can point to ANY type
		// I don't know what datatype I'll be pointing to
		// so it's casted to whatever type I want/suits the input date
Structure
	-> you can copy the contents of a struct IF they have the same template
		struct name ahmed, amr;
		ahmed = amr;
	-> cannot do arithmetic/equality operations on structs
		amr = ahmed + 20; // error
		amr += ahmed; // error
		if (ahmed == arm) // error
		int x = ahmed + amr; // error
	-> passing struct to function:
		void func(struct employee mystruct);
		.
		.
		.
		func(ahmed);
	-> returning structs
		struct employee func(...)
		{
			struct employee x;
			.
			.
			.
			return x;
		}
	-> alternative way to defining structs
		typedef struct 
		{
			.
			.
			.
		} employee;
		void func(employee x);
	-> Size of structures *WINKWINK*
		memory padding is a bitch
		so, to preserve both memory size and performance,
		order the struct elements ascendingly/descendingly 
		to get the best outcome
		### if the word size for the toolchain is not mentioned
			assume it'll be the largest of the variables inside the struct
		__attribute && #pragma pack(no_of_bytes) are also used to optimize padding
	-> Bitfield (compiler dependent)
		restricts a struct variable to a number of bits
		typedef struct
		{
			s8 x : 3;
			s8 y : 2;
		} my_struct;
		.
		.
		.
		my_struct s1;
		s1.x = 0b111; // for some reason interviewers love this shit! XDDD
		printf("%d", s1.x); // prints -1 cuz it's a signed number

## Reusable Firmware Development (book that makes you create REUSABLE code that runs on all compilers)

Union usecase
	-> defining a union that contains a struct inside it *OH, MY!*
		typedef union
		{
			struct 
			{
				u8 B0 : 1;
				u8 B1 : 1;
				u8 B2 : 1;
				u8 B3 : 1;
				u8 B4 : 1;
				u8 B5 : 1;
				u8 B6 : 1;
				u8 B7 : 1;
			} bit;
			u8 byte;
		} register;
		.
		.
		.
		register r1;
		r1.byte = 10; // writes 10 (in decimal) to ALL bit locations
		r1.bit.B0 = 1; // writes 1 on bit 0 ONLY
		// it's basically used to define registers
		
enum
	-> used to eliminate magic numbers (numbers that should have some meaning in the code context)
	-> ex:
		enum
		{
			sunday, // automatically renames it to 0
			monday, // to 1
			.
			.
			.
		}
	-> can also assign values to the enum elements:
		enum
		{
			sunday = 2, 
			monday, // the following elements always have incremented values = 4
			.
			.
			.
		}
	-> It is better to use enum and not #define due to:
		1. Using the right compiler+debugger combination, the debugger will print 
		enumeration variables by their enumeration name and not by their number. So 
		"StateBlahBlup" reads much nicer than "41", doesn't it?
		
		2. You don't have explicitly give every state a number, the compiler 
		does the numbering for you if you let it. Let's assume you have already 
		20 states and you want to add a new state in the middle, in case of defines, 
		you have to do all renumbering on your own. In case of enumeration, you can 
		just add the state and the compiler will renumber all states below this new 
		state for you.
		
		3. You can tell the compiler to warn you if a switch statement does not handle
		all the possible enum values, e.g. because you forgot to handle some values or 
		because the enum was extended but you forgot to also update the switch statements
		handling enum values (it will not warn if there's a default case though, as all 
		values not handled explicitly end up in the default case).
		
Paths of header files:
	-> Absolute path (not used cuz it conflicts with project sharing)
		#include "D:/new/mylib.h" // actual header file path
	-> Relative path (This one is mostly used)
		#include "mylib.h" // header file should be present in the source file folder
	-> to go back in directory
		#include "../lib.h"
		
EXTRA (Assignment)
	-> set_bit(u8 var, u8 bit);
	-> clr_bit(u8 var, u8 bit);
	-> tog_bit(u8 var, u8 bit);

----------------------------------------------------------------------------------
==================================================================================
----------------------------------------------------------------------------------
#Day 07 (9/8/2023)

Bro_Tip:
	-> to write on multiple lines in notepad++/any cool IDE:
		highlight x lines using left click while pressing ALT at the same time
		   Just like this! UwU
		   Just like this! UwU
		   Just like this! UwU
		   
Dynamic Memory Allocation
	-> RAM consists of the following sections:
		.data => stores global + static initialized variables
		.bss => stores global + static uninitialized variables (OS MOSTLY initializes them to 0)
		Stack => local variables + static allocation (at compile time)
			ex: int arr[5] = {1, 2, 3, 4, 5};
		Heap => dynamically allocated data (@runtime)
		.text
		OR
		.code => stores (most of) code
		
	-> malloc(): reserves x bytes in heap and returns a void* to it
		1. syntax:
			malloc(size_in_bytes);
		2. malloc() should always be casted to the type for which you want to reserve memory
		3. ex:
			u8* ptr = NULL; // NULL is either pos 0 in memory or out of bounds pos
			ptr = (u8*)malloc(7);
			// you can then write to each byte individually
			ptr[0] = sth; // or *(ptr + 0) = sth;
			ptr[3] = sth_else; // or *(ptr + 3) = sth_else;
	
	-> calloc(): same as malloc() but initializes the allocated space to zero
		1. syntax:
			calloc(no_of_blocks, size_of_blocks_in_bytes);
		2. ex:
			u32* ptr;
			ptr = (u32*)calloc(5, sizeof(u32));
		

	malloc() 		vs 			calloc()
	memory allocate 		contiguous allocate
	1 argument 					2 arguments
	size in bytes			no of blocks && size of block
	returns void* to 		returns void* to
	1st byte				1st byte
	faster						slower
			
	#NOTE:
		Dynamically-allocated data stays in Heap (no relation to stack)
		
	-> free(): frees the dynamically-allocated memory you created with malloc/calloc
		1. syntax:
			free(ptr_to_dynamic_mem); // pass the pointer to the allocated mem
		2. MUST DO to avoid memory leaks
		
	-> realloc(): reallocates the size of previously reserved memory
		1. syntax:
			realloc(ptr, new_size_in_bytes);
		2. ex:
			u32* ptr = (u32*)malloc(10 + sizeof(u32));
			.
			.
			.
			realloc(ptr, 20 * sizeof(u32)); // total bytes will be 20*4 instead of 10*4

Array 			    vs  		Linked List
Time of access					Time of access is 
is constant						variable (depends on how far it is from head)
Fixed size						No unused memory (very efficient way to use it)
No extra memory					Extra memory usage due to pointer
Static Allocation				Dynamic Allocation

----------------------------------------------------------------------------------
==================================================================================
----------------------------------------------------------------------------------
# Day 08 (10/8/2023)

----------------------------------------------------------------------------------
==================================================================================
----------------------------------------------------------------------------------
# Day 09 (14/8/2023)

Eclipse Setup

DIO
	-> 4 Ports, each one has the following: (x stands for A B C D)
		1. DDRx: for direction (0 for in && 1 for out)
		2. PORTx: for output (1 for high && 0 for low) --- (must configure DDRx beforehand)
		3. PINx: for input (1 for high && 0 for low) --- (not configured: read-only)
		
	-> Connection:
		Sourcing: mc acts as current source for device (5V)
		Sinking: mc acts as current sink (0V)
		## Must check sink and source limits (20mA-40mA for both)
		
Superloop Architecture
	
## All registers are included in <avr/io.h>
## Built-in delay function <utils/delay.h>

Delay:
	->_delay_ms(time_in_ms);
	-> _delay_us(time_in_us);
		
### enum ONLY reserves memory only when it has been used
### Both macros and enums do not consume memory on declaration (Both are basically the same!)
### enums are smarter: they initialize the first value to 1 and AUTOMATICALLY
	increments this value and stores it in the second element and so on
## enums are a better replacement of macros

### Difference between typedef and macros
	-> typedef == equality
	-> macros == text replacement
	
## Assigment:
	-> apply some led animation
	
----------------------------------------------------------------------------------
==================================================================================
----------------------------------------------------------------------------------
# Day 10 (15/8/2023)

Switches:
	1. Momentary
	2. Maintained
	-> When pressed == 0V or 5V
	-> When not pressed == floating (not desired)
	-> MUST connect pull-up/pull-down resistor to give a defined state when switch is opened
# in AVR, there is an internal pull-up resistor
# to use it:
	1. make pin as input (DDRx = 0)
	2. set pin to high SET_PIN(PORTx, Pxx);

	-> how to fix?
		1. Hardware: using capacitors || RC filter || schmitt trigger
		2. Software: add a delay after reading the button's state (100ms) (to let the rippling pass)
		
Layered Architecture
	-> each module contains 5 files (for simplicity use only 1 & 2)
		1. interface file (dio.h) --- (macros for user + func prototypes)
		2. program file (dio.c) --- (implementation of funcs)
		interface.h (func prototypes)
		private.h (stuff that should be only visible to this module)
		registers.h (register array for this module)
		prog.c (func implementation)
		cfg.h (macros + enums + modes of operations)
		
	-> Naming convention:
		1. local:	u8 local_u8Var; // start by local then write its type then its name
		2. function argument (pass by value): u8 copy_u8Var; // copy then type then name
		3. functions: moduleName_retTypeName(); // module name then return type then name
		4. camel case: sthLikeThis
		5. pascal case: SthLikeThis
		6. snake case: Sth_Like_This
	
----------------------------------------------------------------------------------
==================================================================================
----------------------------------------------------------------------------------
# Day 11 (16/8/2023)

Configuration Types:
	-> prebuilt/precompiled config
	-> postbuild config
	-> link-time config
	
	1. prebuilt/precompiled:
		-> by using macros
			#define LED_PORT DIO_PORTA
			#define LED_PIN DIO_PIN0
	### TAKE CARE OF #include ORDER! ###
	2. post-build config
		-> using structs for example
			typedef struct
			{
				u8 port;
				u8 pin;
			} LED_t;
	### FOOD FOR THOUGHT:
		MAYBE, try implementing drivers using structs (mainly for HAL)
	3. link-time
		-> config.c => config.o
			give the customer config.o and let them link it themselves with their other files
			## More for security reasons
			
Types of Displays:
1. LED display
2. Segment display
3. Dot matrix
## LED displays disadvantages:
	-> high power consumption per led
	-> consume a lot of pins
## LED displays advantages
	-> eye-catching
	-> excellent view angles
	-> small compact sizes

Prerequisites for LCD:
1. Light Polarization
	-> light is an EMW
	-> non-polarized light == light traveling in all directions/planes
	-> light + polarizer = polarized light (travels in one direction/plane only)
	# Polarizer:
		-> vertical
		-> horizontal
2. Liquid crystal
	-> at STP, it's in a liquid-y state
	-> its internal structure changes by applying a voltage effect

# this is the concept behind LCD
	-> light polarization
		2 polarizers (one vertical and one horizontal)
	-> liquid crystal
		apply current => no light will pass through horizontal polarizer

LCD Types
1. Segment LCD (looks like a couple of 7seg stuck together)
2. Alpha-numeric/character LCD
3. graphical LCD

# LCD Module: LED source + liquid crystal + polarizer + panel + built-in mc

### How will my mc communicate with the LCD's mc?
	-> Via 8-line parallel communication
	-> byte-by-byte

LCD Pins:
	-> Power Pins (3 pins):
		VSS -> GND
		VDD -> 5v (Vcc) 
		Vo -> contrast control (0-5V) --- controlled by potentiometer (behaving according to voltage division rule)
	-> Control Pins (3 pins)
		RS -> (register select) (0 for command || 1 for data)
		# commands like clear_display, cursor_location, shift_display
		R/W' -> 0 for Write || 1 for read (busy flag: wait for LCD to execute command || read data from LCD)
		E -> enable signal (rising edge to start reading from databus || falling edge to start writing from databus on LCD)
	-> Data Pins (8 pins): send data & commands
		D0
		.
		.
		.
		D7
	-> Backlight Pins (2 pins)
		A -> 5V
		K -> GND
		
## VCC/VDD => connected to high (5V)
## VSS/VEE => connected to low (GND/0V)

Potentiometer => VCC Vo GND (connect Vo the LCD's Vo at Vo XDDD)

Connection of mc to LCD:
	-> PORTx => D0-D7
	-> Px =>RS
	-> Px => E
	-> Px => R/W' (R/W' can be connected to GND instead)
	
## We need our software to be independent on the connection
## HOW?
## Using pre-build configuration
	#define LCD_DATA_PORT DIO_PORTA
	#define LCD_CTRL_PORT DIO_PORTB
	#define LCD_CTRL_RS DIO_PIN0
	#define LCD_CTRL_E DIO_PIN1
	#define LCD_CTRL_RW DIO_PIN2
	
## in 4-bit mode, D0->D3 are left floating (data is transmitted on D4->D7 only)
## in 8-bit mode, D0->D7 are all connected normally

### in 4-bit mode: MS Nibble is sent first, then LS Nibble

### CHECK THE INITIALIZATION STEPS OF LCD IN ITS DATASHEET

## DL == mode
## N == no of lines
## F == font types (5x11 or 5x8)

LCD APIs needed:
	-> initialization
	-> send char
	-> send string
	-> send command (clear, set cursor, etc)
	-> send int
	-> send float

----------------------------------------------------------------------------------
==================================================================================
----------------------------------------------------------------------------------
# Day 12 (17/8/2023)

Keypad Idea of Operation
	-> 4x4 keypad consists of 16 button, with 4 col terminals and 4 row terminals
	-> in order to read a button press:
		1. put all cols to high, read rows (rows are connected to INTERNAL mc pull-up resistors---default logic is 1)
		2. Activate col0 by putting it to low ###, then read rows for any change in logic values
			(pressed buttons will give logic 0)
		3. change the activated col periodically to read the remaining buttons

Algorithm:
1. Outer loop to activate Col0->Col3
2. Inner loop to check on Row0->Row3
3. If Rowx is low, it is then pressed -> register this button press -> break
4. return the pressed button

Normal duration of a single press = 250ms

If the user is a عيل رخم and keeps pressing the button
we can wait UNTIL the button is unpressed (busy wait aka polling)

Config:
	-> KEYPAD_COL_PIN0 -> PIN3 (assign them to DIO_PIN4->DIO_PIN7 (OUTPUT--PU))
	-> KEYPAD_ROW_PIN0 -> PIN3 (assign them to DIO_PIN0->DIO_PIN3 (INPUT))

APIs:
	-> keypad_init (activate pull-ups @cols + set col0-3 direction to out && row0-3 to in)
	-> read_button (the algorithm above and it should return the char/num corresponding to the pressed button)
		## store all the weird-ass combinations as enums then as a 2d array of said enums ##
	
### Header Guard ONLY prevents multiple definitions of preprocessor directives
### defining an array for example and including the header multiple times will 
### result in multiple definition of array!
########Answer:
Global variable's scope is ALL of the project BUT not all of the project's files can use it...?!
MUST USE extern in each file that uses that array/variable

# Extra Assignment #
	-> Simple Garage System:
		2x 7 segment + 2x switches + 2x LEDs (red for full && green for empty space)
		Car entering = INC displayed count
		Car exiting = DES displayed count
		MAX Car count = 25 cars
		
	-> Simple Calculator:
		Add && Sub 2 numbers (keep each a single digit)
		pressing '=' will calculate and display the result
		
Switches
	-> Mechanical
	-> Electrical

Electrical Switches
	-> Why? easier/more convenient to control stuff electrically
	-> Actuated by electrical signal (no hooman interaction)
	-> action is taken by mc
	-> act as a layer of isolation between mc and component (that may consume high power)
	1. PN Junction (diode)--passes current in one direction only
	2. Transistor 
		-> cutoff == base = GND && emitter = VCC && collector = VCC (oc) ###
		-> saturation == base = VCC && emitter = GND && collector = VCC (sc-ish) ###
		-> active == base = VCC && emitter = collector = GND (as amplifier)
		ex: 
			connect mc to base of transistor (case 0: off || case 1: on)
			connect emitter to GND
			connect collector to VCC
			
----------------------------------------------------------------------------------
==================================================================================
----------------------------------------------------------------------------------
# Day 13 (20/8/2023)

H-Bridge
Optocoupler
Relay
SPST
SPDT
DPDT
Darlington Pair
DC Motor
Buzzer
Stepper Motor
APIs for stepper:
	1. init()
	2. rotate_clk()
	3. rotate_anticlk()
	4. set_angle()
	5. set_speed()
	
----------------------------------------------------------------------------------
==================================================================================
----------------------------------------------------------------------------------
# Day 14 (21/8/2023)

Interrupts *SCREAMS*

Dynamics Systems:
	1. Superloop (do this code FOREVER!)
	2. Foreground/Background (Superloop + Interrupt-based)
		
-> Peripheral interrupt enable (key for a specific interrupt)
-> global interrupt enable (allows interrupts to happen---not necessarily respond to them unless they are enabled)
-> Peripheral interrupt flag (interrupt event itself)

In order for a peripheral to have interrupt:
	1. enable PIE
	2. enable GIE

How are interrupts handled?
	-> vectored priority (each interrupt has its own unique ISR)
		
	-> flexible/non-vectored priority (same ISR for all interrupts---only execute the one who's flag is set)
		(ordered from highest to lowest priority---use if statements not if-else)

What happens when 2 interrupts occur at the same time?
	-> serve the one with the highest priority first
There are no Nested interrupts in AVR

Interrupt Types:
	1. internal (inside processor)
		fetch -> wrong address -> interrupt
		decode -> wrong op code -> interrupt
		execute -> divide by zero -> interrupt
		# SW interrupts
			provides increased privilage (access registers that are not normally allowed0)
	2. External
		peripherals: ADC, EXTI, ...

When interrupt is triggered:
	1. complete current instruction
	2. disable global interrupt enable
	3. push PC in stack (Context Switching)
	4. push CPU registers (PSW, GPRs) (Context Switching)
	5. Jmp to vector table and fetch the address of the ISR 
	6. Jmp to ISR (execute it)
	*after it is done*
	7. enable global interrupts
	8. reload pre-ISR values of cpu registers (Context Switching)
	9. reload pre-ISR PC value (Context Switching)
	*continue normal operation*
	
Context Switching (ISRs && function calls)
	ISRs have HW privilages
	normal function do not have that
	
Interrupt Mask
	-> Mask: can be ignored
	-> Non-Maskable: cannot be ignored (like reset)
	
Interrupt latency = interrupt response time (differs per operation) + ISR execution time

External Interrupt (EXTI)
	1. Level-triggered (INT0, INT1)
		low
		high
	2. Edge-triggered (INT0, INT1)
		rising edge (INT2)
		falling edge (INT2)
	
EXTI Registers:
	MCU Control Register (MCUCR)
	-> set event trigger for INT0 and INT1 by writting ISCxx bits
	
	(SREG)
	-> set the I-flag 
	
	MCUCSR (for INT2)
	
	General Interrupt Control (GICR)
	-> Enables peripheral interrupts 
	
	General Interrupt Flag Register (GIFR)
		
Coding:
	-> ISR => ISR for interrupts (called by passing a parameter indicating the ISR specific for a specific interrupt)
	-> sei => enable global interrupts (used as init function)
	-> cli => diable global interrupts
	
Initialization:
	-> choose the sense control from MCUCR/MCUSR
	-> Input pull-up or not 
	-> Enable the interrupt from GICR
	
	
	### make a function that does ONLY one thing SOLID principle in OOP
	
APIs Needed:
	-> initialization
	-> enable EXTI
	-> disable EXTI

### how to decrease interrupt latency?
decrease execution time inside ISR
decrease context switching time (kinda not possible)

### WHAT TO WRITE IN EACH FILE 
	-> Prog.c == function implementations + static functions
	-> Interface.h == Stuff that the user will see and MUST KNOW (not change) to interact with thy driver
	-> CFG.h == Stuff the user is allowed to change to configure the driver to their liking
	-> Register.h == do I really need to explain this one?
	-> Private.h == stuff used in driver but the user must not see/use/modify
### Apparently, just including Interface.h in your project is enough... NEED TO TEST THIS!

----------------------------------------------------------------------------------
==================================================================================
----------------------------------------------------------------------------------
# Day 15 (22/8/2023)

Volatile keyword
	-> tells the optimizer to skip any optimization it wants to make
	-> used for variables that CONSTANTLY change values and it is crucial to 
	   acknowledge all these changes and the optimizer SHOULD NOT change/modify its behaviour
	-> used in:
		register definitions
		global variables used in ISR

ADC (Analog to Digital Converter)

Converting from Analog to Digital:
	1. Sampling 
		(a rate at which values are taken)
		(Nyquist rate is the ultimate optimal rate ==> fs = 2*fm)
	2. Quantization 
		(approximate samples' values to the nearest quantization level)
		(Parameters: Resolution (bits/sample) && Max Value (Vmax))
	3. Coding 
		(Each quantization level it given a unique code)
		
## How to improve ADC performance?
	=> by increasing the resolution/number of bits
	=> decreasing the Max Value Vmax
	
## Saturation Voltage (voltage level at which nothing beyond it will be measured---it will always register as Vmax)
## Vsat = Vmax - Vstep

## Quality of signal is determined by: Sampling Rate
## Resolution (bits/sample) ==> memory/processing power trade-off

## Vref == Vmax

ADC contains a DAC...?!
Analog Sample = Vstep * Coded_Sample_Value

ADC Parameters:
	1. Conversion Time
		time to convert to digital
		Tc_min = 1 clk cycle @ zero input voltage
		Tc_max = 2^resolution @ all one input voltage
		## Sample freq > conversion time ##
	2. Errors
		quantization error
		propagation delay/error @ ADC CLK >> conversion
		

Types of ADC:
	1. RAMP ADC
	
	2. SAR ADC (Successive Approximation Register)
		same as RAMP but with different counter
		
APIs needed:
	1. initialize 
		-> choose prescaler
		-> mode (10 bit, 8 bit)
		-> Vref ?
		-> Enable ADC
	2. ReadDigitalSync (channel)
		-> choose channel
		-> start conversion
		-> polling on flag (HELL NO!)
		-> clear flag
		-> return result
	3. ReadDigitalAsync (channel)
		-> choose channel
		-> enable interrupt
		-> start conversion
	4. disableADC
	5. enableADC
	6. Source Trigger
	
### Input frequency for ATmega32 must be between 50kHz & 200kHz 

### putting UL after a number in multiplication indicates that 
### the result of this operation is u32 ###

Sensors

# Temperature Sensor LM35
# LDR
# Thermistor

# Lab_2 is an assignment (ADC)
# Lab_1 is an assignment (Sensors)
# LDR Lab is an assignment (Sensors)

----------------------------------------------------------------------------------
==================================================================================
----------------------------------------------------------------------------------
# Day 16 (23/8/2023)

Callback:
	-> instead of defining the function ptr, make it typedef
		void (*ptrFunc)(void);
		typedef void (*ptrFunc)(void);
		ptrFunc ptr1 = NULL; // can be used just like this
		## naming your function ptr has to include its arg and return type
		ptrFunc_Ivoid_Ovoid
		
## MODIFICATION To STD_Types ##
	1. add enum bool
	2. add enum ERRORS
	3. add NULL
	4. add typedef ptrFunc_voidI_voidO
	
Timer